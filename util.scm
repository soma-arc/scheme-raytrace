(define-module util
  (use srfi-27)
  (use math.const)
  (use vec :prefix v:)
  (export-all))

(select-module util)

(define (random-in-unit-sphere)
  (let loop ((p (v:diff (v:scale (v:vec3 (random-real) (random-real) (random-real)) 2)
                        (v:vec3 1 1 1))))
    (if (< (v:sq-len p) 1)
        p
        (loop (v:diff (v:scale (v:vec3 (random-real) (random-real) (random-real)) 2)
                      (v:vec3 1 1 1))))))

(define (random-in-unit-disk)
  (let loop ((p (v:diff (v:scale (v:vec3 (random-real) (random-real) 0) 2)
                        (v:vec3 1 1 0))))
    (if (< (v:dot p p) 1)
        p
        (loop (v:diff (v:scale (v:vec3 (random-real) (random-real) 0) 2)
                      (v:vec3 1 1 0))))))

(define (random-dir-over-hemisphere n)
  (let loop ()
    (let ((p (v:scale (v:diff (v:vec3 (random-real) (random-real) (random-real))
                              (v:vec3 0.5 0.5 0.5))
                      2)))
      (if (>= (v:sq-len p) 1)
          (loop)
          (let ((dir (v:unit p)))
            (if (< (v:dot dir n) 0)
                (v:scale dir -1)
                dir))))))

(define (random-cosine-direction)
  (let* ((r1 (random-real))
         (r2 (random-real))
         (z (sqrt (- 1 r2)))
         (phi (* 2 pi r1))
         (x (* (cos phi) 2 (sqrt r2)))
         (y (* (sin phi) 2 (sqrt r2))))
    (v:vec3 x y z)))

(define (random-to-sphere radius distance-sq)
  (let* ((r1 (random-real))
         (r2 (random-real))
         (z (+ 1 (* r2 (- (sqrt (- 1 (/ (* radius radius)
                                        distance-sq))) 1))))
         (phi (* 2 pi r1))
         (x (* (cos phi) (sqrt (- 1 (* z z)))))
         (y (* (sin phi) (sqrt (- 1 (* z z))))))
    (v:vec3 x y z)))

